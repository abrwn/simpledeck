<!DOCTYPE html>
<html lang="en">

<head>
  <title>SimpleDeck - a lightweight single deck for DJing</title>
  <meta name="theme-color" content="#333">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html,
    body {
      margin: 0;
      overscroll-behavior: none;
      height: 100%;
    }

    .root {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 25rem;
      background: #333;
      height: 100%;
      box-sizing: border-box;
      padding: 1rem 0rem 2rem 0.5rem;
    }

    button {
      background: #555;
      color: #ccc;
      font-weight: bold;
      font-size: 0.75rem;
      font-family: Helvetica, sans-serif;
      letter-spacing: 1.5px;
      border: 2px solid #444;
      transition: background-color 0.3s;
    }

    button:disabled {
      color: #999;
    }

    button:active {
      background: #666;
    }

    input::file-selector-button {
      height: 2.5rem;
      border-radius: 25px;
      /* padding-inline: 5rem; */
      background: #555;
      color: #ccc;
      font-weight: bold;
      font-size: 0.75rem;
      font-family: Helvetica, sans-serif;
      letter-spacing: 1.5px;
      border: 2px solid #444;
      transition: background-color 0.3s;
      margin-right: 1rem;
      padding-inline: 1rem;
      cursor: pointer;
    }

    input::file-selector-button:active {
      background: #666;
    }

    .file-picker {
      margin-right: auto;
      margin-left: 1rem;
    }

    .file-picker input {
      color: #ccc;
      font-weight: bold;
      font-size: 0.75rem;
      font-family: Helvetica, sans-serif;
      letter-spacing: 1.5px;
    }

    .time-remaining {
      margin-left: auto;
      font-weight: bold;
      font-size: 0.75rem;
      font-family: Helvetica, sans-serif;
      letter-spacing: 1.5px;
      color: #999;
      margin-top: 1.25rem;
    }

    .time-remaining.loaded {
      color: #ccc;
    }

    .left-panel {
      height: 100%;
    }

    .flex-container {
      display: flex;
      width: 100%;
    }

    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
      width: 1px;
    }

    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      border: 2px solid #777;
      height: 2.5rem;
      width: 1rem;
      border-radius: 4px;
      margin-top: -19px;
      background: rgba(255, 255, 255, 0.1);
      cursor: pointer;
      z-index: 2;
    }

    input[type=range]::-webkit-slider-runnable-track {
      height: 2px;
      cursor: pointer;
      background: #222;
      border-radius: 2px;
    }

    .tempo-slider {
      display: flex;
      position: relative;
      align-items: center;
      justify-content: center;
    }

    .tempo-slider input {
      height: 90%;
      width: 4rem;
      writing-mode: vertical-lr;
    }

    .tempo-slider input[type=range]::-webkit-slider-thumb {
      height: 1rem;
      width: 2.5rem;
      margin-top: unset;
      margin-left: -20px;
    }

    .tempo-slider input[type=range]::-webkit-slider-runnable-track {
      width: 2px;
    }

    .zero-notch {
      position: absolute;
      border: 1px solid #222;
      width: 1.5rem;
      pointer-events: none;
    }

    .progress-slider {
      display: flex;
      justify-content: center;
      width: 100%;
      position: relative;
      align-items: center;
      margin: 1.75rem 1rem 1.75rem 2rem;
      flex-direction: column;
    }

    .progress-slider input {
      width: 100%;
      margin-inline: 1rem;
    }

    .cue-point-container {
      position: absolute;
      box-sizing: border-box;
      width: 100%;
      pointer-events: none;
      top: -5px;
      padding-inline: 7px;
    }

    .cue-point {
      border: 1px solid #ed2d07;
      height: 100%;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      justify-content: space-between;
    }


    .buttons button {
      border-radius: 50%;
      aspect-ratio: 1;
      width: 50%;
    }

    .playback-buttons button {
      margin: 1rem;
    }

    #play.on {
      border-color: lightgreen;
      box-shadow: 0 0 4px 1px lightgreen;
    }

    #cue.on {
      border-color: orange;
      box-shadow: 0 0 4px 1px orange;
    }

    .on {
      transition: all 0.1s;
    }

    .seek-buttons button,
    .pitch-buttons button {
      margin: 1rem 2rem;
    }

    .seek-buttons button:active,
    .pitch-buttons button:active {
      border-color: #ed2d07;
      box-shadow: 0 0 4px 1px #ed2d07;
      transition: 0.1s;
    }

    .set-cue-button button {
      height: 2.5rem;
      border-radius: 25px;
      width: 100%;
      padding-inline: 5rem;
      margin: 1rem;
    }
  </style>
</head>
<script type="module">
  import { h, render } from 'https://esm.sh/preact';
  import { useState, useRef, useEffect } from 'https://esm.sh/preact/hooks';
  import htm from 'https://esm.sh/htm';

  const html = htm.bind(h);

  function App(props) {
    const audioStates = {
      PLAYING: 'PLAYING',
      CUEING: 'CUEING',
    };

    const pointsToUse = {
      PAUSE: 'PAUSE',
      CUE: 'CUE',
    };

    const [audioState, setAudioState] = useState(null);
    const [cuePoint, setCuePoint] = useState(0);
    const [pausePoint, setPausePoint] = useState(0);
    const [tempo, setTempo] = useState(1);
    const [pointToUse, setPointToUse] = useState(pointsToUse.PAUSE);
    const [duration, setDuration] = useState(null);
    const [timeRemaining, setTimeRemaining] = useState(null);
    const [hasSongLoaded, setHasSongLoaded] = useState(false);
    const [isScrubbing, setIsScrubbing] = useState(false);
    const [isUsingPressurePitchBend, setIsUsingPressurePitchBend] = useState(false);

    const currentTime = useRef(0);
    const intervalRef = useRef();

    const audioCtx = useRef();
    const buffer = useRef();
    const source = useRef();

    const counterSource = useRef();
    const counterBuffer = useRef();
    const prp = useRef();

    const onFileChange = async (event) => {
      setHasSongLoaded(false);

      currentTime.current = 0;
      setAudioState(null);
      setCuePoint(0);
      setPausePoint(0);
      setTempo(1);
      setPointToUse(pointsToUse.PAUSE);
      setTimeRemaining(null);

      audioCtx.current = new AudioContext();
      audioCtx.current.audioWorklet.addModule('reporter.js');

      const file = event.target.files[0];
      const fileBuffer = await file.arrayBuffer();
      try {
        buffer.current = await audioCtx.current.decodeAudioData(fileBuffer);
        setDuration(buffer.current.duration);

        counterBuffer.current = audioCtx.current.createBuffer(1, buffer.current.length, audioCtx.current.sampleRate);
        const length = counterBuffer.current.length
        const counterBufferCD = counterBuffer.current.getChannelData(0);
        for (let i = 0; i < length; ++i) {
          // Clamp to [0; 1].
          // Could clamp to [-1; 1) for higher precision, but it makes handling 0 troublesome.
          counterBufferCD[i] = i / length;
        }
        setHasSongLoaded(true);

        try {
          await navigator.wakeLock.request('screen');
        } catch (err) {
          alert(`Request to keep screen on denied:  ${err.name}, ${err.message}`);
        }
      } catch (err) {
        alert(`Unable to load the audio file. Error: ${err.message}`);
      }
    };

    const startPlaybackAtTime = (offset = 0, speed = tempo) => {
      if (source.current) {
        source.current.stop();
      }
      if (counterSource.current) {
        counterSource.current.stop();
      }

      source.current = audioCtx.current.createBufferSource();
      source.current.buffer = buffer.current;
      source.current.connect(audioCtx.current.destination);

      counterSource.current = audioCtx.current.createBufferSource();
      counterSource.current.buffer = counterBuffer.current;


      prp.current = new AudioWorkletNode(audioCtx.current, 'position-reporting-processor');
      prp.current.port.onmessage = (e) => {
        currentTime.current = e.data * duration
      }

      counterSource.current.connect(prp.current);
      prp.current.connect(audioCtx.current.destination);

      source.current.start(0, offset);
      counterSource.current.start(0, offset);
      updatePlaybackSpeed(speed);
    };

    const pausePlayback = () => {
      counterSource.current.disconnect(prp.current);
      prp.current.disconnect();

      source.current.stop();
      counterSource.current.stop();
      setAudioState(null);
    };

    const updatePlaybackSpeed = (speed = tempo) => {
      source.current.playbackRate.value = speed;
      counterSource.current.playbackRate.value = speed;
    };

    const onPlayToggle = (e) => {
      e.preventDefault();

      if (!audioState) {
        const point = pointToUse === pointsToUse.CUE ? cuePoint : pausePoint;
        setAudioState(audioStates.PLAYING);
        startPlaybackAtTime(point);
      } else if (audioState === audioStates.CUEING) {
        // Switch to continue playing if play button hit while cueing
        setAudioState(audioStates.PLAYING);
      } else {
        pausePlayback();
        setPausePoint(currentTime.current);
        setPointToUse(pointsToUse.PAUSE);
      }
    };

    const onSetCueDown = (e) => {
      e.preventDefault();

      setCuePoint(currentTime.current);
    };

    const onCueDown = (e) => {
      e.preventDefault();

      setAudioState(audioStates.CUEING);
      startPlaybackAtTime(cuePoint);
    };

    const onCueUp = (e) => {
      e.preventDefault();

      setPointToUse(pointsToUse.CUE);

      if (audioState === audioStates.CUEING) {
        pausePlayback();
        currentTime.current = cuePoint;
      }
    };

    const pitchChangeIntervalRef = useRef();
    const onPitchBendPlusDown = (e) => {
      e.preventDefault();

      if (audioState && !isUsingPressurePitchBend) {
        let pitchMultiplier = 1;
        pitchChangeIntervalRef.current = setInterval(() => {
          if (pitchMultiplier < 2) {
            pitchMultiplier += 0.005;
            updatePlaybackSpeed(tempo * pitchMultiplier);
          }
        }, 30);
      }
    };

    const onPitchBendMinusDown = (e) => {
      e.preventDefault();

      if (audioState && !isUsingPressurePitchBend) {
        let pitchMultiplier = 1;
        pitchChangeIntervalRef.current = setInterval(() => {
          if (pitchMultiplier < 2) {
            pitchMultiplier += 0.005;
            updatePlaybackSpeed(tempo / pitchMultiplier);
          }
        }, 30);
      }
    };

    const onPitchBendUp = (e) => {
      clearInterval(pitchChangeIntervalRef.current);
      setIsUsingPressurePitchBend(false);
      e.preventDefault();

      if (audioState) {
        updatePlaybackSpeed();
      }
    };

    const onSeekForwardDown = (e) => {
      e.preventDefault();

      const speed = audioState ? 3 : 6;
      startPlaybackAtTime(currentTime.current, speed);
    };

    const onSeekBackDown = (e) => {
      e.preventDefault();

      const speed = audioState ? -3 : -6;
      startPlaybackAtTime(currentTime.current, speed);
    };

    const onSeekUp = (e) => {
      e.preventDefault();

      if (audioState) {
        updatePlaybackSpeed();
      } else {
        setPointToUse(pointsToUse.PAUSE);
        setPausePoint(currentTime.current);
        pausePlayback();
      }
    };

    const onPitchChange = (e) => {
      e.preventDefault();

      setTempo(e.target.value / 100);
    };

    const onScrubUp = (e) => {
      const newPoint = duration * e.target.value / 100;
      if (audioState) {
        startPlaybackAtTime(newPoint);
      } else {
        currentTime.current = newPoint;
        setPausePoint(newPoint);
      }
      setTimeout(() => setIsScrubbing(false), 100);
    }

    useEffect(() => {
      if (source.current) {
        updatePlaybackSpeed(tempo);
      }
    }, [tempo]);

    const remainingInterval = useRef();
    useEffect(() => {
      clearInterval(remainingInterval.current);
      remainingInterval.current = setInterval(() => {
        setTimeRemaining(Math.round(duration - currentTime.current));
      }, 100);
    }, [duration]);

    const pitchMinusButtonRef = useRef();
    const pitchPlusButtonRef = useRef();

    useEffect(() => {
      const onPitchMinusForceChange = (e) => {
        if (audioState) {
          e.preventDefault()
          if (e.webkitForce === 0) {
            setIsUsingPressurePitchBend(false)
            updatePlaybackSpeed()
          } else {
            updatePlaybackSpeed(tempo / (((e.webkitForce - 1) / 2) + 1));
          }
        }
      };

      const onPitchPlusForceChange = (e) => {
        if (audioState) {
          e.preventDefault()
          if (e.webkitForce === 0) {
            setIsUsingPressurePitchBend(false)
            updatePlaybackSpeed()
          } else {
            updatePlaybackSpeed(tempo * (((e.webkitForce - 1) / 2) + 1))
          }
        }
      };

      const onPitchChangeForceWillBegin = (e) => {
        e.preventDefault();
        setIsUsingPressurePitchBend(true);
      }

      pitchMinusButtonRef.current.addEventListener('webkitmouseforcechanged', onPitchMinusForceChange)
      pitchPlusButtonRef.current.addEventListener('webkitmouseforcechanged', onPitchPlusForceChange)
      pitchMinusButtonRef.current.addEventListener('webkitmouseforcewillbegin', onPitchChangeForceWillBegin);
      pitchPlusButtonRef.current.addEventListener('webkitmouseforcewillbegin', onPitchChangeForceWillBegin);

      return () => {
        pitchMinusButtonRef.current.removeEventListener('webkitmouseforcechanged', onPitchMinusForceChange)
        pitchPlusButtonRef.current.removeEventListener('webkitmouseforcechanged', onPitchPlusForceChange)
        pitchMinusButtonRef.current.removeEventListener('webkitmouseforcewillbegin', onPitchChangeForceWillBegin);
        pitchPlusButtonRef.current.removeEventListener('webkitmouseforcewillbegin', onPitchChangeForceWillBegin);
      };
    }, [audioState, tempo])

    return html`
        <div class="root">
          <div class="file-picker">
            <input
              onchange=${onFileChange} 
              type="file">
            </input>
          </div>
          <div class="left-panel flex-container">
            <div class="buttons">
              <div class="progress-slider">
                <div class="cue-point-container">
                  <vr class="cue-point" style="margin-left: ${(cuePoint / duration * 100) || 0}%;" />
                </div>
                <input 
                  step="0.1" 
                  type="range" 
                  min="0" 
                  max="100" 
                  value=${isScrubbing ? undefined : (currentTime.current / duration * 100 || 0)}
                  onMouseDown=${() => setIsScrubbing(true)}
                  onChange=${onScrubUp}>
                </input>
                <div class="time-remaining ${hasSongLoaded ? 'loaded' : ''}">
                  -${timeRemaining / 60 | 0}:${String(timeRemaining % 60).padStart(2, '0')} / ${Math.round(duration) / 60 | 0}:${String(Math.round(duration) % 60).padStart(2, '0')}
                </div>
              </div>
              <div class="seek-buttons flex-container">
                <button disabled=${!hasSongLoaded} onMouseDown=${onSeekBackDown} onTouchStart=${onSeekBackDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>Seek -</button>
                <button disabled=${!hasSongLoaded} onMouseDown=${onSeekForwardDown} onTouchStart=${onSeekForwardDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>Seek +</button>
              </div>
              <div class="pitch-buttons flex-container">
                <button 
                  disabled=${!hasSongLoaded}
                  ref=${pitchMinusButtonRef} 
                  onMouseDown=${onPitchBendMinusDown}
                  onTouchStart=${onPitchBendMinusDown}
                  onMouseUp=${onPitchBendUp}
                  onTouchEnd=${onPitchBendUp}
                >
                  Pitch -
                </button>
                <button 
                  disabled=${!hasSongLoaded}  
                  ref=${pitchPlusButtonRef} 
                  onMouseDown=${onPitchBendPlusDown}
                  onTouchStart=${onPitchBendPlusDown}
                  onMouseUp=${onPitchBendUp}
                  onTouchEnd=${onPitchBendUp}
                >
                  Pitch +
                </button>
              </div>
              <div class="set-cue-button flex-container">
                <button disabled=${!hasSongLoaded} onMouseDown=${onSetCueDown} onTouchStart=${onSetCueDown}>Set Cue</button>
              </div>
              <div class="playback-buttons flex-container">
                <button 
                  class="${audioState === audioStates.PLAYING ? 'on' : ''}"
                  id="play"
                  disabled=${!hasSongLoaded} 
                  onMouseDown=${onPlayToggle} 
                  onTouchStart=${onPlayToggle}
                >
                  Play/Pause
                </button>
                <button 
                  class="${audioState === audioStates.CUEING ? 'on' : ''}"
                  id="cue"
                  disabled=${!hasSongLoaded} 
                  onMouseDown=${onCueDown} 
                  onTouchStart=${onCueDown} 
                  onMouseUp=${onCueUp} 
                  onTouchEnd=${onCueUp}
                >
                  Cue
                </button>
              </div>
            </div>
            <div class="tempo-slider">
              <hr class="zero-notch" />
              <input step="0.1" type="range" min="90" max="110" orient="vertical" onInput=${onPitchChange}></input>
            </div>
          </div>
        </div>
        `;
  }

  render(html`<${App} />`, document.body);
</script>

</html>