<!DOCTYPE html>
<html lang="en">
  <head>
    <title>SimpleDeck - a lightweight single deck for DJing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .root {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .time-remaining {
        margin: 1rem 0;
      }

      .controls {
        display: flex;
      }

      .buttons {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .playback-buttons button {
        border-radius: 50%;
        width: 5.5rem;
        margin: 1rem;
        aspect-ratio: 1;
      }

      .seek-buttons button, .pitch-buttons button {
        border-radius: 50%;
        width: 4.25rem;
        aspect-ratio: 1;
        margin: 1rem;
      }

      .set-cue-button {
        width: 100%;
        display: flex;
      }

      .set-cue-button button {
        height: 2.5rem;
        border-radius: 25%;
        width: 100%;
        padding-inline: 5rem;
        margin: 1rem;
      }

      .slider input {
        appearance: slider-vertical; 
        height: 100%;
        width: 5rem;
        transform: scaleY(-1);
      }
    </style>
  </head>
  <script type="module">
    import { h, render } from 'https://esm.sh/preact';
    import { useState, useRef, useEffect } from 'https://esm.sh/preact/hooks';
    import htm from 'https://esm.sh/htm';
    
    const html = htm.bind(h);
    
    function App(props) {
      const audioStates = {
        PLAYING: 'PLAYING',
        CUEING: 'CUEING',
      };
    
      const pointsToUse = {
        PAUSE: 'PAUSE',
        CUE: 'CUE',
      };
    
      const [audioState, setAudioState] = useState(null);
      const [cuePoint, setCuePoint] = useState(0);
      const [pausePoint, setPausePoint] = useState(0);
      const [tempo, setTempo] = useState(1);
      const [pointToUse, setPointToUse] = useState(pointsToUse.PAUSE);
      const [duration, setDuration] = useState(null);
      const [timeRemaining, setTimeRemaining] = useState(null);
      const [hasSongLoaded, setHasSongLoaded] = useState(false);
    
      const currentTime = useRef(0);
      const intervalRef = useRef();
    
      const audioCtx = useRef();
      const buffer = useRef();
      const source = useRef();
      
      const counterSource = useRef();
      const counterBuffer = useRef();
      const prp = useRef();

      useEffect(async () => {
        try {
          await navigator.wakeLock.request('screen');
        } catch(err) {
          console.error('WakeLock request denied', err.name, err.message);
        }
      }, []);
    
      const onFileChange = async (event) => {
        setHasSongLoaded(false);

        currentTime.current = 0;
        setAudioState(null);
        setCuePoint(0);
        setPausePoint(0);
        setTempo(1);
        setPointToUse(pointsToUse.PAUSE);
        setTimeRemaining(null);

        audioCtx.current = new AudioContext();
        audioCtx.current.audioWorklet.addModule('reporter.js');
    
        const file = event.target.files[0];
        const fileBuffer = await file.arrayBuffer();
        try {
          buffer.current = await audioCtx.current.decodeAudioData(fileBuffer);
          setDuration(buffer.current.duration);

          counterBuffer.current = audioCtx.current.createBuffer(1, buffer.current.length, audioCtx.current.sampleRate);
          const length = counterBuffer.current.length
          const counterBufferCD = counterBuffer.current.getChannelData(0);
          for (let i = 0; i < length; ++i) {
            // Clamp to [0; 1].
            // Could clamp to [-1; 1) for higher precision, but it makes handling 0 troublesome.
            counterBufferCD[i] = i / length;
          }
          setHasSongLoaded(true);
        } catch (err) {
          alert(`Unable to load the audio file. Error: ${err.message}`);
        }
      };
    
      const startPlaybackAtTime = (offset = 0, speed = tempo) => {
        if (source.current) {
           source.current.stop();
        }
        if (counterSource.current) {
           counterSource.current.stop();
        }

        source.current = audioCtx.current.createBufferSource();
        source.current.buffer = buffer.current;
        source.current.connect(audioCtx.current.destination);

        counterSource.current = audioCtx.current.createBufferSource();
        counterSource.current.buffer = counterBuffer.current;


        prp.current = new AudioWorkletNode(audioCtx.current, 'position-reporting-processor');
        prp.current.port.onmessage = (e) => {
          currentTime.current = e.data * duration
        }

        counterSource.current.connect(prp.current);
        prp.current.connect(audioCtx.current.destination);

        source.current.start(0, offset);
        counterSource.current.start(0, offset);
        updatePlaybackSpeed(speed);
      };
    
      const pausePlayback = () => {
        counterSource.current.disconnect(prp.current);
        prp.current.disconnect();

        source.current.stop();
        counterSource.current.stop();
        setAudioState(null);
      };
    
      const updatePlaybackSpeed = (speed = tempo) => {
        source.current.playbackRate.value = speed;
        counterSource.current.playbackRate.value = speed;
      };
    
      const onPlayToggle = (e) => {
        e.preventDefault();
        
        if (!audioState) {
          const point = pointToUse === pointsToUse.CUE ? cuePoint : pausePoint;
          setAudioState(audioStates.PLAYING);
          startPlaybackAtTime(point);
        } else if (audioState === audioStates.CUEING) {
          // Switch to continue playing if play button hit while cueing
          setAudioState(audioStates.PLAYING);
        } else {
          pausePlayback();
          setPausePoint(currentTime.current);
          setPointToUse(pointsToUse.PAUSE);
        }
      };
    
      const onSetCueDown = (e) => {
        e.preventDefault();
        
        setCuePoint(currentTime.current);
      };

      const onCueDown = (e) => {
        e.preventDefault();

        setAudioState(audioStates.CUEING);
        startPlaybackAtTime(cuePoint);
      };
    
      const onCueUp = (e) => {
        e.preventDefault();

        setPointToUse(pointsToUse.CUE);
    
        if (audioState === audioStates.CUEING) {
          pausePlayback();
          currentTime.current = cuePoint;
        }
      };
    
      const onPitchBendPlusDown = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed(tempo * 1.1);
        }
      };
    
      const onPitchBendMinusDown = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed(tempo / 1.1);
        }
      };
    
      const onPitchBendUp = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed();
        }
      };
    
      const onSeekForwardDown = (e) => {
        e.preventDefault();

        const speed = audioState ? 3 : 6;
        startPlaybackAtTime(currentTime.current, speed);
      };
    
      const onSeekBackDown = (e) => {
        e.preventDefault();

        const speed = audioState ? -3 : -6;
        startPlaybackAtTime(currentTime.current, speed);
      };
    
      const onSeekUp = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed();
        } else {
          setPointToUse(pointsToUse.PAUSE);
          setPausePoint(currentTime.current);
          pausePlayback();
        }
      };
    
      const onPitchChange = (e) => {
        e.preventDefault();

        setTempo(e.target.value / 100);
      };
    
      useEffect(() => {
        if (source.current) {
          updatePlaybackSpeed(tempo);
        }
      }, [tempo]);
    
      const remainingInterval = useRef();
      useEffect(() => {
        clearInterval(remainingInterval.current);
        remainingInterval.current = setInterval(() => {
          setTimeRemaining(Math.round(duration - currentTime.current)); 
        }, 100);
      }, [duration]);
    
      return html`
        <div class="root">
          <div>
            <input onchange=${onFileChange} type="file"></input>
            <div class="time-remaining">
              Time remaining: -${timeRemaining/60|0}:${String(timeRemaining%60).padStart(2, '0')} / ${Math.round(duration)/60|0}:${String(Math.round(duration)%60).padStart(2, '0')}
            </div>
          </div>
          <div class="controls">
            <div class="buttons">
              <div class="seek-buttons">
                <button disabled=${!hasSongLoaded} onMouseDown=${onSeekBackDown} onTouchStart=${onSeekBackDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>SEEK BACK</button>
                <button disabled=${!hasSongLoaded} onMouseDown=${onSeekForwardDown} onTouchStart=${onSeekForwardDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>SEEK FWD</button>
              </div>
              <div class="pitch-buttons">
                <button disabled=${!hasSongLoaded} onMouseDown=${onPitchBendMinusDown} onTouchStart=${onPitchBendMinusDown} onMouseUp=${onPitchBendUp} onTouchEnd=${onPitchBendUp}>PITCH BEND -</button>
                <button disabled=${!hasSongLoaded} onMouseDown=${onPitchBendPlusDown} onTouchStart=${onPitchBendPlusDown} onMouseUp=${onPitchBendUp} onTouchEnd=${onPitchBendUp}>PITCH BEND +</button>
              </div>
              <div class="set-cue-button">
                <button disabled=${!hasSongLoaded} onMouseDown=${onSetCueDown} onTouchStart=${onSetCueDown}>SET CUE</button>
              </div>
              <div class="playback-buttons">
                <button disabled=${!hasSongLoaded} onMouseDown=${onPlayToggle} onTouchStart=${onPlayToggle}>PLAY/PAUSE</button>
                <button disabled=${!hasSongLoaded} onMouseDown=${onCueDown} onTouchStart=${onCueDown} onMouseUp=${onCueUp} onTouchEnd=${onCueUp}>CUE</button>
              </div>
            </div>
            <div class="slider">
              <input step="0.1" type="range" min="90" max="110" orient="vertical" onInput=${onPitchChange}></input>
            </div>
          </div>
        </div>
        `;
    }
    
    render(html`<${App} />`, document.body);
  </script>
</html>