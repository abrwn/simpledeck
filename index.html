<!DOCTYPE html>
<html lang="en">
  <head>
    <title>SimpleDeck - a lightweight single deck for DJing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      .root {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .time-remaining {
        margin: 1rem 0;
      }

      .controls {
        display: flex;
      }

      .buttons {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .playback-buttons button {
        border-radius: 50%;
        width: 5.5rem;
        margin: 1rem;
        aspect-ratio: 1;
      }

      .seek-buttons button, .pitch-buttons button {
        border-radius: 50%;
        width: 4.25rem;
        aspect-ratio: 1;
        margin: 1rem;
      }

      .slider input {
        appearance: slider-vertical; 
        height: 100%;
        width: 5rem;
        transform: scaleY(-1);
      }
    </style>
  </head>
  <script type="module">
    import { h, render } from 'https://esm.sh/preact';
    import { useState, useRef, useEffect } from 'https://esm.sh/preact/hooks';
    import htm from 'https://esm.sh/htm';
    
    const html = htm.bind(h);
    
    function App(props) {
      const audioStates = {
        PLAYING: 'PLAYING',
        CUEING: 'CUEING',
      };
    
      const pointsToUse = {
        PAUSE: 'PAUSE',
        CUE: 'CUE',
      };
    
      const [audioState, setAudioState] = useState(null);
      const [cuePoint, setCuePoint] = useState(0);
      const [pausePoint, setPausePoint] = useState(0);
      const [tempo, setTempo] = useState(1);
      const [pointToUse, setPointToUse] = useState(pointsToUse.PAUSE);
      const [duration, setDuration] = useState(null);
      const [timeRemaining, setTimeRemaining] = useState(null);
    
      const currentTime = useRef(0);
      const intervalRef = useRef();
    
      const audioCtx = useRef();
      const buffer = useRef();
      const source = useRef();
      
      const counterSource = useRef();
      const counterBuffer = useRef();
      const prp = useRef();
    
      const onFileChange = async (event) => {
        audioCtx.current = new AudioContext();
        audioCtx.current.audioWorklet.addModule('reporter.js');
    
        const file = event.target.files[0];
        const fileBuffer = await file.arrayBuffer();
        try {
          buffer.current = await audioCtx.current.decodeAudioData(fileBuffer);
          setDuration(buffer.current.duration);

          counterBuffer.current = audioCtx.current.createBuffer(1, buffer.current.length, audioCtx.current.sampleRate);
          const length = counterBuffer.current.length
          const counterBufferCD = counterBuffer.current.getChannelData(0);
          for (let i = 0; i < length; ++i) {
            // Clamp to [0; 1).
            // Could clamp to [-1; 1) for higher precision, but it makes handling 0 troublesome.
            counterBufferCD[i] = i / length;
          }
          console.log('Loaded')
        } catch (err) {
          console.error(`Unable to fetch the audio file. Error: ${err.message}`);
        }
      };
    
      const startPlaybackAtTime = (offset = 0, speed = tempo) => {
        if (source.current) {
           source.current.stop();
        }
        if (counterSource.current) {
           counterSource.current.stop();
        }

        source.current = audioCtx.current.createBufferSource();
        source.current.buffer = buffer.current;
        source.current.connect(audioCtx.current.destination);

        counterSource.current = audioCtx.current.createBufferSource();
        counterSource.current.buffer = counterBuffer.current;


        prp.current = new AudioWorkletNode(audioCtx.current, 'position-reporting-processor');
        prp.current.port.onmessage = (e) => {
          currentTime.current = e.data * duration
        }

        counterSource.current.connect(prp.current);
        prp.current.connect(audioCtx.current.destination);

        source.current.start(0, offset);
        counterSource.current.start(0, offset);
        updatePlaybackSpeed(speed);
      };
    
      const pausePlayback = () => {
        if (audioState) {
          counterSource.current.disconnect(prp.current);
          prp.current.disconnect();
        }
        source.current.stop();
        counterSource.current.stop();
        setAudioState(null);
      };
    
      const updatePlaybackSpeed = (speed = tempo) => {
        source.current.playbackRate.value = speed;
        counterSource.current.playbackRate.value = speed;
      };
    
      const onPlayToggle = (e) => {
        e.preventDefault();
        
        if (!audioState) {
          const point = pointToUse === pointsToUse.CUE ? cuePoint : pausePoint;
          setAudioState(audioStates.PLAYING);
          startPlaybackAtTime(point);
        } else if (audioState === audioStates.CUEING) {
          // Switch to continue playing if play button hit while cueing
          setAudioState(audioStates.PLAYING);
        } else {
          pausePlayback();
          setPausePoint(currentTime.current);
          setPointToUse(pointsToUse.PAUSE);
        }
      };
    
      const onCueDown = (e) => {
        e.preventDefault();

        if (audioState === audioStates.PLAYING) {
          pausePlayback();
        } else {
          if (currentTime.current === cuePoint) {
            setAudioState(audioStates.CUEING);
            startPlaybackAtTime(cuePoint);
          } else {
            pausePlayback();
            setCuePoint(currentTime.current);
          }
        }
      };
    
      const onCueUp = (e) => {
        e.preventDefault();

        setPointToUse(pointsToUse.CUE);
    
        if (audioState === audioStates.CUEING) {
          pausePlayback();
          currentTime.current = cuePoint;
        }
      };
    
      const onPitchBendPlusDown = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed(tempo * 1.1);
        }
      };
    
      const onPitchBendMinusDown = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed(tempo / 1.1);
        }
      };
    
      const onPitchBendUp = (e) => {
        e.preventDefault();

        if (audioState) {
          updatePlaybackSpeed();
        }
      };
    
      const onSeekForwardDown = (e) => {
        e.preventDefault();

        if (source.current) {
          startPlaybackAtTime(currentTime.current, 3);
        }
      };
    
      const onSeekBackDown = (e) => {
        e.preventDefault();

        if (source.current) {
          startPlaybackAtTime(currentTime.current, -3);
        }
      };
    
      const onSeekUp = (e) => {
        e.preventDefault();

        if (source.current) {
          if (audioState) {
            updatePlaybackSpeed();
          } else {
            setPointToUse(pointsToUse.PAUSE);
            setPausePoint(currentTime.current);
            pausePlayback();
          }
        }
      };
    
      const onPitchChange = (e) => {
        e.preventDefault();

        setTempo(e.target.value / 100);
      };
    
      useEffect(() => {
        if (source.current) {
          updatePlaybackSpeed(tempo);
        }
      }, [tempo]);
    
      const remainingInterval = useRef();
      useEffect(() => {
        clearInterval(remainingInterval.current);
        remainingInterval.current = setInterval(() => {
          setTimeRemaining(Math.round(duration - currentTime.current)); 
        }, 100);
      }, [duration]);
    
      return html`
        <div class="root">
          <div>
            <input onchange=${onFileChange} type="file"></input>
            <div class="time-remaining">Time remaining: -${timeRemaining/60|0}:${String(timeRemaining%60).padStart(2, '0')}</div>
          </div>
          <div class="controls">
            <div class="buttons">
              <div class="seek-buttons">
                <button onMouseDown=${onSeekBackDown} onTouchStart=${onSeekBackDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>SEEK BACK</button>
                <button onMouseDown=${onSeekForwardDown} onTouchStart=${onSeekForwardDown} onMouseUp=${onSeekUp} onTouchEnd=${onSeekUp}>SEEK FWD</button>
              </div>
              <div class="pitch-buttons">
                <button onMouseDown=${onPitchBendMinusDown} onTouchStart=${onPitchBendMinusDown} onMouseUp=${onPitchBendUp} onTouchEnd=${onPitchBendUp}>PITCH BEND -</button>
                <button onMouseDown=${onPitchBendPlusDown} onTouchStart=${onPitchBendPlusDown} onMouseUp=${onPitchBendUp} onTouchEnd=${onPitchBendUp}>PITCH BEND +</button>
              </div>
              <div class="playback-buttons">
                <button onMouseDown=${onPlayToggle} onTouchStart=${onPlayToggle}>PLAY/PAUSE</button>
                <button onMouseDown=${onCueDown} onTouchStart=${onCueDown} onMouseUp=${onCueUp} onTouchEnd=${onCueUp}>CUE</button>
              </div>
            </div>
            <div class="slider">
              <input step="0.1" type="range" min="90" max="110" orient="vertical" onInput=${onPitchChange}></input>
            </div>
          </div>
        </div>
        `;
    }
    
    render(html`<${App} />`, document.body);
  </script>
</html>